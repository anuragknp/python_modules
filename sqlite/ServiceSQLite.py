#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def ExecuteStatementArray(self, dir_level, db_name, statement_array, user_id, wrap_inside_transaction, sqlite_flags, app_name, busy_timeout):
    """
    Parameters:
     - dir_level
     - db_name
     - statement_array
     - user_id
     - wrap_inside_transaction
     - sqlite_flags
     - app_name
     - busy_timeout
    """
    pass

  def ping(self, ):
    pass

  def InitUserDirectories(self, user_id):
    """
    Parameters:
     - user_id
    """
    pass

  def GetMaintenance(self, user_id):
    """
    Parameters:
     - user_id
    """
    pass

  def SetMaintenance(self, user_id, conf):
    """
    Parameters:
     - user_id
     - conf
    """
    pass

  def RemoveMaintenance(self, user_id):
    """
    Parameters:
     - user_id
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def ExecuteStatementArray(self, dir_level, db_name, statement_array, user_id, wrap_inside_transaction, sqlite_flags, app_name, busy_timeout):
    """
    Parameters:
     - dir_level
     - db_name
     - statement_array
     - user_id
     - wrap_inside_transaction
     - sqlite_flags
     - app_name
     - busy_timeout
    """
    self.send_ExecuteStatementArray(dir_level, db_name, statement_array, user_id, wrap_inside_transaction, sqlite_flags, app_name, busy_timeout)
    return self.recv_ExecuteStatementArray()

  def send_ExecuteStatementArray(self, dir_level, db_name, statement_array, user_id, wrap_inside_transaction, sqlite_flags, app_name, busy_timeout):
    self._oprot.writeMessageBegin('ExecuteStatementArray', TMessageType.CALL, self._seqid)
    args = ExecuteStatementArray_args()
    args.dir_level = dir_level
    args.db_name = db_name
    args.statement_array = statement_array
    args.user_id = user_id
    args.wrap_inside_transaction = wrap_inside_transaction
    args.sqlite_flags = sqlite_flags
    args.app_name = app_name
    args.busy_timeout = busy_timeout
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ExecuteStatementArray(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ExecuteStatementArray_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exception_sqlite is not None:
      raise result.exception_sqlite
    if result.exception_file_system is not None:
      raise result.exception_file_system
    if result.exception_machine_maintenance is not None:
      raise result.exception_machine_maintenance
    if result.exception_user_maintenance is not None:
      raise result.exception_user_maintenance
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ExecuteStatementArray failed: unknown result");

  def ping(self, ):
    self.send_ping()
    self.recv_ping()

  def send_ping(self, ):
    self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
    args = ping_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ping(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ping_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def InitUserDirectories(self, user_id):
    """
    Parameters:
     - user_id
    """
    self.send_InitUserDirectories(user_id)
    self.recv_InitUserDirectories()

  def send_InitUserDirectories(self, user_id):
    self._oprot.writeMessageBegin('InitUserDirectories', TMessageType.CALL, self._seqid)
    args = InitUserDirectories_args()
    args.user_id = user_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_InitUserDirectories(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = InitUserDirectories_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.exception_file_system is not None:
      raise result.exception_file_system
    return

  def GetMaintenance(self, user_id):
    """
    Parameters:
     - user_id
    """
    self.send_GetMaintenance(user_id)
    return self.recv_GetMaintenance()

  def send_GetMaintenance(self, user_id):
    self._oprot.writeMessageBegin('GetMaintenance', TMessageType.CALL, self._seqid)
    args = GetMaintenance_args()
    args.user_id = user_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetMaintenance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = GetMaintenance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exception_file_system is not None:
      raise result.exception_file_system
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetMaintenance failed: unknown result");

  def SetMaintenance(self, user_id, conf):
    """
    Parameters:
     - user_id
     - conf
    """
    self.send_SetMaintenance(user_id, conf)
    self.recv_SetMaintenance()

  def send_SetMaintenance(self, user_id, conf):
    self._oprot.writeMessageBegin('SetMaintenance', TMessageType.CALL, self._seqid)
    args = SetMaintenance_args()
    args.user_id = user_id
    args.conf = conf
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_SetMaintenance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = SetMaintenance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.exception_file_system is not None:
      raise result.exception_file_system
    return

  def RemoveMaintenance(self, user_id):
    """
    Parameters:
     - user_id
    """
    self.send_RemoveMaintenance(user_id)
    self.recv_RemoveMaintenance()

  def send_RemoveMaintenance(self, user_id):
    self._oprot.writeMessageBegin('RemoveMaintenance', TMessageType.CALL, self._seqid)
    args = RemoveMaintenance_args()
    args.user_id = user_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_RemoveMaintenance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = RemoveMaintenance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.exception_file_system is not None:
      raise result.exception_file_system
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["ExecuteStatementArray"] = Processor.process_ExecuteStatementArray
    self._processMap["ping"] = Processor.process_ping
    self._processMap["InitUserDirectories"] = Processor.process_InitUserDirectories
    self._processMap["GetMaintenance"] = Processor.process_GetMaintenance
    self._processMap["SetMaintenance"] = Processor.process_SetMaintenance
    self._processMap["RemoveMaintenance"] = Processor.process_RemoveMaintenance

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_ExecuteStatementArray(self, seqid, iprot, oprot):
    args = ExecuteStatementArray_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ExecuteStatementArray_result()
    try:
      result.success = self._handler.ExecuteStatementArray(args.dir_level, args.db_name, args.statement_array, args.user_id, args.wrap_inside_transaction, args.sqlite_flags, args.app_name, args.busy_timeout)
    except ExceptionSQLite as exception_sqlite:
      result.exception_sqlite = exception_sqlite
    except ExceptionFileSystem as exception_file_system:
      result.exception_file_system = exception_file_system
    except ExceptionMachineUnderMaintenance as exception_machine_maintenance:
      result.exception_machine_maintenance = exception_machine_maintenance
    except ExceptionUserUnderMaintenance as exception_user_maintenance:
      result.exception_user_maintenance = exception_user_maintenance
    oprot.writeMessageBegin("ExecuteStatementArray", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ping(self, seqid, iprot, oprot):
    args = ping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ping_result()
    self._handler.ping()
    oprot.writeMessageBegin("ping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_InitUserDirectories(self, seqid, iprot, oprot):
    args = InitUserDirectories_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = InitUserDirectories_result()
    try:
      self._handler.InitUserDirectories(args.user_id)
    except ExceptionFileSystem as exception_file_system:
      result.exception_file_system = exception_file_system
    oprot.writeMessageBegin("InitUserDirectories", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetMaintenance(self, seqid, iprot, oprot):
    args = GetMaintenance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetMaintenance_result()
    try:
      result.success = self._handler.GetMaintenance(args.user_id)
    except ExceptionFileSystem as exception_file_system:
      result.exception_file_system = exception_file_system
    oprot.writeMessageBegin("GetMaintenance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_SetMaintenance(self, seqid, iprot, oprot):
    args = SetMaintenance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = SetMaintenance_result()
    try:
      self._handler.SetMaintenance(args.user_id, args.conf)
    except ExceptionFileSystem as exception_file_system:
      result.exception_file_system = exception_file_system
    oprot.writeMessageBegin("SetMaintenance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_RemoveMaintenance(self, seqid, iprot, oprot):
    args = RemoveMaintenance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = RemoveMaintenance_result()
    try:
      self._handler.RemoveMaintenance(args.user_id)
    except ExceptionFileSystem as exception_file_system:
      result.exception_file_system = exception_file_system
    oprot.writeMessageBegin("RemoveMaintenance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class ExecuteStatementArray_args:
  """
  Attributes:
   - dir_level
   - db_name
   - statement_array
   - user_id
   - wrap_inside_transaction
   - sqlite_flags
   - app_name
   - busy_timeout
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dir_level', None, None, ), # 1
    (2, TType.STRING, 'db_name', None, None, ), # 2
    (3, TType.LIST, 'statement_array', (TType.STRUCT,(Statement, Statement.thrift_spec)), None, ), # 3
    (4, TType.I64, 'user_id', None, -1, ), # 4
    (5, TType.BOOL, 'wrap_inside_transaction', None, False, ), # 5
    (6, TType.I64, 'sqlite_flags', None, 0, ), # 6
    (7, TType.STRING, 'app_name', None, None, ), # 7
    (8, TType.I64, 'busy_timeout', None, 10, ), # 8
  )

  def __init__(self, dir_level=None, db_name=None, statement_array=None, user_id=thrift_spec[4][4], wrap_inside_transaction=thrift_spec[5][4], sqlite_flags=thrift_spec[6][4], app_name=None, busy_timeout=thrift_spec[8][4],):
    self.dir_level = dir_level
    self.db_name = db_name
    self.statement_array = statement_array
    self.user_id = user_id
    self.wrap_inside_transaction = wrap_inside_transaction
    self.sqlite_flags = sqlite_flags
    self.app_name = app_name
    self.busy_timeout = busy_timeout

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dir_level = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.statement_array = []
          (_etype71, _size68) = iprot.readListBegin()
          for _i72 in xrange(_size68):
            _elem73 = Statement()
            _elem73.read(iprot)
            self.statement_array.append(_elem73)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.user_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.wrap_inside_transaction = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.sqlite_flags = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.app_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.busy_timeout = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExecuteStatementArray_args')
    if self.dir_level is not None:
      oprot.writeFieldBegin('dir_level', TType.I32, 1)
      oprot.writeI32(self.dir_level)
      oprot.writeFieldEnd()
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 2)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.statement_array is not None:
      oprot.writeFieldBegin('statement_array', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.statement_array))
      for iter74 in self.statement_array:
        iter74.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.user_id is not None:
      oprot.writeFieldBegin('user_id', TType.I64, 4)
      oprot.writeI64(self.user_id)
      oprot.writeFieldEnd()
    if self.wrap_inside_transaction is not None:
      oprot.writeFieldBegin('wrap_inside_transaction', TType.BOOL, 5)
      oprot.writeBool(self.wrap_inside_transaction)
      oprot.writeFieldEnd()
    if self.sqlite_flags is not None:
      oprot.writeFieldBegin('sqlite_flags', TType.I64, 6)
      oprot.writeI64(self.sqlite_flags)
      oprot.writeFieldEnd()
    if self.app_name is not None:
      oprot.writeFieldBegin('app_name', TType.STRING, 7)
      oprot.writeString(self.app_name)
      oprot.writeFieldEnd()
    if self.busy_timeout is not None:
      oprot.writeFieldBegin('busy_timeout', TType.I64, 8)
      oprot.writeI64(self.busy_timeout)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dir_level is None:
      raise TProtocol.TProtocolException(message='Required field dir_level is unset!')
    if self.db_name is None:
      raise TProtocol.TProtocolException(message='Required field db_name is unset!')
    if self.statement_array is None:
      raise TProtocol.TProtocolException(message='Required field statement_array is unset!')
    if self.user_id is None:
      raise TProtocol.TProtocolException(message='Required field user_id is unset!')
    if self.wrap_inside_transaction is None:
      raise TProtocol.TProtocolException(message='Required field wrap_inside_transaction is unset!')
    if self.sqlite_flags is None:
      raise TProtocol.TProtocolException(message='Required field sqlite_flags is unset!')
    if self.app_name is None:
      raise TProtocol.TProtocolException(message='Required field app_name is unset!')
    if self.busy_timeout is None:
      raise TProtocol.TProtocolException(message='Required field busy_timeout is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExecuteStatementArray_result:
  """
  Attributes:
   - success
   - exception_sqlite
   - exception_file_system
   - exception_machine_maintenance
   - exception_user_maintenance
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ResultSetArrayAndTimeTaken, ResultSetArrayAndTimeTaken.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exception_sqlite', (ExceptionSQLite, ExceptionSQLite.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'exception_file_system', (ExceptionFileSystem, ExceptionFileSystem.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'exception_machine_maintenance', (ExceptionMachineUnderMaintenance, ExceptionMachineUnderMaintenance.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'exception_user_maintenance', (ExceptionUserUnderMaintenance, ExceptionUserUnderMaintenance.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, exception_sqlite=None, exception_file_system=None, exception_machine_maintenance=None, exception_user_maintenance=None,):
    self.success = success
    self.exception_sqlite = exception_sqlite
    self.exception_file_system = exception_file_system
    self.exception_machine_maintenance = exception_machine_maintenance
    self.exception_user_maintenance = exception_user_maintenance

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ResultSetArrayAndTimeTaken()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exception_sqlite = ExceptionSQLite()
          self.exception_sqlite.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.exception_file_system = ExceptionFileSystem()
          self.exception_file_system.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.exception_machine_maintenance = ExceptionMachineUnderMaintenance()
          self.exception_machine_maintenance.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.exception_user_maintenance = ExceptionUserUnderMaintenance()
          self.exception_user_maintenance.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExecuteStatementArray_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exception_sqlite is not None:
      oprot.writeFieldBegin('exception_sqlite', TType.STRUCT, 1)
      self.exception_sqlite.write(oprot)
      oprot.writeFieldEnd()
    if self.exception_file_system is not None:
      oprot.writeFieldBegin('exception_file_system', TType.STRUCT, 2)
      self.exception_file_system.write(oprot)
      oprot.writeFieldEnd()
    if self.exception_machine_maintenance is not None:
      oprot.writeFieldBegin('exception_machine_maintenance', TType.STRUCT, 3)
      self.exception_machine_maintenance.write(oprot)
      oprot.writeFieldEnd()
    if self.exception_user_maintenance is not None:
      oprot.writeFieldBegin('exception_user_maintenance', TType.STRUCT, 4)
      self.exception_user_maintenance.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InitUserDirectories_args:
  """
  Attributes:
   - user_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'user_id', None, None, ), # 1
  )

  def __init__(self, user_id=None,):
    self.user_id = user_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.user_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InitUserDirectories_args')
    if self.user_id is not None:
      oprot.writeFieldBegin('user_id', TType.I64, 1)
      oprot.writeI64(self.user_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user_id is None:
      raise TProtocol.TProtocolException(message='Required field user_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InitUserDirectories_result:
  """
  Attributes:
   - exception_file_system
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exception_file_system', (ExceptionFileSystem, ExceptionFileSystem.thrift_spec), None, ), # 1
  )

  def __init__(self, exception_file_system=None,):
    self.exception_file_system = exception_file_system

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exception_file_system = ExceptionFileSystem()
          self.exception_file_system.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InitUserDirectories_result')
    if self.exception_file_system is not None:
      oprot.writeFieldBegin('exception_file_system', TType.STRUCT, 1)
      self.exception_file_system.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetMaintenance_args:
  """
  Attributes:
   - user_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'user_id', None, None, ), # 1
  )

  def __init__(self, user_id=None,):
    self.user_id = user_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.user_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetMaintenance_args')
    if self.user_id is not None:
      oprot.writeFieldBegin('user_id', TType.I64, 1)
      oprot.writeI64(self.user_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user_id is None:
      raise TProtocol.TProtocolException(message='Required field user_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetMaintenance_result:
  """
  Attributes:
   - success
   - exception_file_system
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UserMaintenanceConf, UserMaintenanceConf.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exception_file_system', (ExceptionFileSystem, ExceptionFileSystem.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exception_file_system=None,):
    self.success = success
    self.exception_file_system = exception_file_system

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UserMaintenanceConf()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exception_file_system = ExceptionFileSystem()
          self.exception_file_system.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetMaintenance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exception_file_system is not None:
      oprot.writeFieldBegin('exception_file_system', TType.STRUCT, 1)
      self.exception_file_system.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetMaintenance_args:
  """
  Attributes:
   - user_id
   - conf
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'user_id', None, None, ), # 1
    (2, TType.STRUCT, 'conf', (UserMaintenanceConf, UserMaintenanceConf.thrift_spec), None, ), # 2
  )

  def __init__(self, user_id=None, conf=None,):
    self.user_id = user_id
    self.conf = conf

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.user_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.conf = UserMaintenanceConf()
          self.conf.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetMaintenance_args')
    if self.user_id is not None:
      oprot.writeFieldBegin('user_id', TType.I64, 1)
      oprot.writeI64(self.user_id)
      oprot.writeFieldEnd()
    if self.conf is not None:
      oprot.writeFieldBegin('conf', TType.STRUCT, 2)
      self.conf.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user_id is None:
      raise TProtocol.TProtocolException(message='Required field user_id is unset!')
    if self.conf is None:
      raise TProtocol.TProtocolException(message='Required field conf is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetMaintenance_result:
  """
  Attributes:
   - exception_file_system
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exception_file_system', (ExceptionFileSystem, ExceptionFileSystem.thrift_spec), None, ), # 1
  )

  def __init__(self, exception_file_system=None,):
    self.exception_file_system = exception_file_system

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exception_file_system = ExceptionFileSystem()
          self.exception_file_system.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetMaintenance_result')
    if self.exception_file_system is not None:
      oprot.writeFieldBegin('exception_file_system', TType.STRUCT, 1)
      self.exception_file_system.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveMaintenance_args:
  """
  Attributes:
   - user_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'user_id', None, None, ), # 1
  )

  def __init__(self, user_id=None,):
    self.user_id = user_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.user_id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveMaintenance_args')
    if self.user_id is not None:
      oprot.writeFieldBegin('user_id', TType.I64, 1)
      oprot.writeI64(self.user_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user_id is None:
      raise TProtocol.TProtocolException(message='Required field user_id is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveMaintenance_result:
  """
  Attributes:
   - exception_file_system
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exception_file_system', (ExceptionFileSystem, ExceptionFileSystem.thrift_spec), None, ), # 1
  )

  def __init__(self, exception_file_system=None,):
    self.exception_file_system = exception_file_system

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exception_file_system = ExceptionFileSystem()
          self.exception_file_system.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveMaintenance_result')
    if self.exception_file_system is not None:
      oprot.writeFieldBegin('exception_file_system', TType.STRUCT, 1)
      self.exception_file_system.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
